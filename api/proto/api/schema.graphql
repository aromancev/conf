type Token {
    token: String!
    expiresIn: Int!
}

type Confa {
    id: String!
    ownerId: String!
    handle: String!
    title: String!
    description: String!
}

type Confas {
    items: [Confa!]!
    limit: Int!
    nextFrom: String!
}

input ConfaLookup {
    id: String
    ownerId: String
    handle: String
}

input ConfaMask {
    handle: String
    title: String
    description: String
}

type Talk {
    id: String!
    ownerId: String!
    speakerId: String!
    confaId: String!
    roomId: String!
    handle: String!
    title: String!
    description: String!
}

input TalkLookup {
    id: String
    ownerId: String
    speakerId: String
    confaId: String
    handle: String
}

input TalkMask {
    handle: String
    title: String
    description: String
}

type Talks {
    items: [Talk!]!
    limit: Int!
    nextFrom: String!
}

type Claps {
    value: Int!
    userValue: Int!
}

input ClapLookup {
    speakerId: String
    confaId: String
    talkId: String
}

type Event {
    id: ID!
    ownerId: ID!
    roomId: ID!
    createdAt: String!
    payload: EventPayload!
}

type EventPayload {
    type: String!
    payload: String!
}

input EventLookup {
    roomId: ID!
}

type EventFrom {
    id: ID!
    createdAt: String!
}

input EventFromInput {
    id: ID!
    createdAt: String!
}

input EventLimit {
    count: Int! = 100
    seconds: Int!
}

enum EventOrder {
    ASC
    DESC
}

type Events {
    items: [Event!]!
    limit: Int!
    nextFrom: EventFrom
}

type Mutation {
    login(address: String!): String!
    createSession(emailToken: String!): Token!

    createConfa(request: ConfaMask!): Confa!
    updateConfa(where: ConfaLookup! = {}, request: ConfaMask!): Confa!
    createTalk(where: ConfaLookup!, request: TalkMask!): Talk!
    updateTalk(where: TalkLookup! = {}, request: TalkMask!): Talk!
    updateClap(talkId: String!, value: Int!): String!
}

type Query {
    token: Token!

    confas(where: ConfaLookup! = {}, limit: Int! = 100, from: ID): Confas!
    talks(where: TalkLookup! = {}, limit: Int! = 100, from: ID): Talks!
    events(where: EventLookup! = {}, limit: EventLimit!, from: EventFromInput, order: EventOrder): Events!
    aggregateClaps(where: ClapLookup! = {}): Claps!
}
