type Service {
  name: String!
  version: String!
  schema: String!
}

type Event {
    id: String!
    roomId: String!
    payload: EventPayload!
    createdAt: Float!
}

type EventPayload {
    message: EventMessage
    peerState: EventPeerState
    recording: EventRecording
    trackRecording: EventTrackRecording
}

type EventMessage {
    fromId: String!
    text: String!
}

enum PeerStatus {
    joined
    left
}

type EventPeerState {
    peerId: String!
    status: PeerStatus
    tracks: [Track!]!
}

enum RecordingStatus {
    started
    stopped
}

type EventRecording {
    status: RecordingStatus!
}

type EventTrackRecording {
    id: String!
    trackId: String!
}

type Track {
    id: String!
    hint: Hint!
}

enum Hint {
    camera
    screen
    user_audio
    device_audio
}

input EventLookup {
    roomId: String!
}

type EventFrom {
    id: String!
    createdAt: String!
}

input EventFromInput {
    createdAt: String!
    id: String!
}

input EventLimit {
    count: Int! = 100
    seconds: Int
}

enum EventOrder {
    ASC
    DESC
}

type Events {
    items: [Event!]!
    limit: Int!
    nextFrom: EventFrom
}

type Recording {
    key: String!
    roomId: String!
    createdAt: Float!
    startedAt: Float!
    stoppedAt: Float
}

input RecordingLookup {
    roomId: String!
    key: String
}

type RecordingFrom {
    key: String!
}

input RecordingFromInput {
    key: String!
}

type Recordings {
    items: [Recording!]!
    limit: Int!
    nextFrom: RecordingFrom
}

type Query {
    service: Service!

    events(where: EventLookup! = {}, limit: EventLimit!, from: EventFromInput, order: EventOrder): Events!
    recordings(where: RecordingLookup!, limit: Int! = 100, from: RecordingFromInput): Recordings!
}
